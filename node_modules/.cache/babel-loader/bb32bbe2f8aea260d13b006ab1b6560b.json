{"ast":null,"code":"'use strict';\n\nvar hasOwn = require('hasown');\n\nvar VALIDATE = require('./validate');\n\nmodule.exports = function (REGION) {\n  var MAX = Math.max;\n  var MIN = Math.min;\n  var statics = {\n    init: function init() {\n      var exportAsNonStatic = {\n        getIntersection: true,\n        getIntersectionArea: true,\n        getIntersectionHeight: true,\n        getIntersectionWidth: true,\n        getUnion: true\n      };\n      var thisProto = REGION.prototype;\n      var newName;\n      var exportHasOwn = hasOwn(exportAsNonStatic);\n      var methodName;\n\n      for (methodName in exportAsNonStatic) {\n        if (exportHasOwn(methodName)) {\n          newName = exportAsNonStatic[methodName];\n\n          if (typeof newName != 'string') {\n            newName = methodName;\n          }\n\n          ;\n\n          (function (proto, methodName, protoMethodName) {\n            proto[methodName] = function (region) {\n              //<debug>\n              if (!REGION[protoMethodName]) {\n                console.warn('cannot find method ', protoMethodName, ' on ', REGION);\n              } //</debug>\n\n\n              return REGION[protoMethodName](this, region);\n            };\n          })(thisProto, newName, methodName);\n        }\n      }\n    },\n    validate: VALIDATE,\n\n    /**\n     * Returns the region corresponding to the documentElement\n     * @return {Region} The region corresponding to the documentElement. This region is the maximum region visible on the screen.\n     */\n    getDocRegion: function getDocRegion() {\n      return REGION.fromDOM(document.documentElement);\n    },\n    from: function from(reg) {\n      if (reg.__IS_REGION) {\n        return reg;\n      }\n\n      if (typeof document != 'undefined') {\n        if (typeof HTMLElement != 'undefined' && reg instanceof HTMLElement) {\n          return REGION.fromDOM(reg);\n        }\n\n        if (reg.type && typeof reg.pageX !== 'undefined' && typeof reg.pageY !== 'undefined') {\n          return REGION.fromEvent(reg);\n        }\n      }\n\n      return REGION(reg);\n    },\n    fromEvent: function fromEvent(event) {\n      return REGION.fromPoint({\n        x: event.pageX,\n        y: event.pageY\n      });\n    },\n    fromDOM: function fromDOM(dom) {\n      var rect = dom.getBoundingClientRect(); // var docElem = document.documentElement\n      // var win     = window\n      // var top  = rect.top + win.pageYOffset - docElem.clientTop\n      // var left = rect.left + win.pageXOffset - docElem.clientLeft\n\n      return new REGION({\n        top: rect.top,\n        left: rect.left,\n        bottom: rect.bottom,\n        right: rect.right\n      });\n    },\n\n    /**\n     * @static\n     * Returns a region that is the intersection of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region/Boolean}        The intersection region or false if no intersection found\n     */\n    getIntersection: function getIntersection(first, second) {\n      var area = this.getIntersectionArea(first, second);\n\n      if (area) {\n        return new REGION(area);\n      }\n\n      return false;\n    },\n    getIntersectionWidth: function getIntersectionWidth(first, second) {\n      var minRight = MIN(first.right, second.right);\n      var maxLeft = MAX(first.left, second.left);\n\n      if (maxLeft < minRight) {\n        return minRight - maxLeft;\n      }\n\n      return 0;\n    },\n    getIntersectionHeight: function getIntersectionHeight(first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minBottom = MIN(first.bottom, second.bottom);\n\n      if (maxTop < minBottom) {\n        return minBottom - maxTop;\n      }\n\n      return 0;\n    },\n    getIntersectionArea: function getIntersectionArea(first, second) {\n      var maxTop = MAX(first.top, second.top);\n      var minRight = MIN(first.right, second.right);\n      var minBottom = MIN(first.bottom, second.bottom);\n      var maxLeft = MAX(first.left, second.left);\n\n      if (maxTop < minBottom && maxLeft < minRight) {\n        return {\n          top: maxTop,\n          right: minRight,\n          bottom: minBottom,\n          left: maxLeft,\n          width: minRight - maxLeft,\n          height: minBottom - maxTop\n        };\n      }\n\n      return false;\n    },\n\n    /**\n     * @static\n     * Returns a region that is the union of the given two regions\n     * @param  {Region} first  The first region\n     * @param  {Region} second The second region\n     * @return {Region}        The union region. The smallest region that contains both given regions.\n     */\n    getUnion: function getUnion(first, second) {\n      var top = MIN(first.top, second.top);\n      var right = MAX(first.right, second.right);\n      var bottom = MAX(first.bottom, second.bottom);\n      var left = MIN(first.left, second.left);\n      return new REGION(top, right, bottom, left);\n    },\n\n    /**\n     * @static\n     * Returns a region. If the reg argument is a region, returns it, otherwise return a new region built from the reg object.\n     *\n     * @param  {Region} reg A region or an object with either top, left, bottom, right or\n     * with top, left, width, height\n     * @return {Region} A region\n     */\n    getRegion: function getRegion(reg) {\n      return REGION.from(reg);\n    },\n\n    /**\n     * Creates a region that corresponds to a point.\n     *\n     * @param  {Object} xy The point\n     * @param  {Number} xy.x\n     * @param  {Number} xy.y\n     *\n     * @return {Region}    The new region, with top==xy.y, bottom = xy.y and left==xy.x, right==xy.x\n     */\n    fromPoint: function fromPoint(xy) {\n      return new REGION({\n        top: xy.y,\n        bottom: xy.y,\n        left: xy.x,\n        right: xy.x\n      });\n    }\n  };\n  Object.keys(statics).forEach(function (key) {\n    REGION[key] = statics[key];\n  });\n  REGION.init();\n};","map":null,"metadata":{},"sourceType":"script"}