{"ast":null,"code":"'use strict';\n\nvar Region = require('region');\n/**\n *\n * This method is trying to align the sourceRegion to the targetRegion, given the alignment positions\n * and the offsets. It only modifies the sourceRegion\n *\n * This is all well and easy, but if there is a constrainTo region, the algorithm has to take it into account.\n * In this case, it works as follows.\n *\n *  * start with the first alignment position. Aligns the region, adds the offset and then check for the constraint.\n *  * if the constraint condition is ok, return the position.\n *  * otherwise, remember the intersection area, if the regions are intersecting.\n *  * then go to the next specified align position, and so on, computing the maximum intersection area.\n *\n * If no alignment fits the constrainRegion, the sourceRegion will be resized to match it,\n * using the position with the maximum intersection area.\n *\n * Since we have computed the index of the position with the max intersection area, take that position,\n * and align the sourceRegion accordingly. Then resize the sourceRegion to the intersection, and reposition\n * it again, since resizing it might have destroyed the alignment.\n *\n * Return the position.\n *\n * @param {Region} sourceRegion\n * @param {Region} targetRegion\n * @param {String[]} positions\n * @param {Object} config\n * @param {Array} config.offset\n * @param {Region} config.constrain\n * @param {Boolean/Object} config.sync\n *\n * @return {String/Undefined} the chosen position for the alignment, or undefined if no position found\n */\n\n\nfunction ALIGN_TO_NORMALIZED(sourceRegion, targetRegion, positions, config) {\n  targetRegion = Region.from(targetRegion);\n  config = config || {};\n  var constrainTo = config.constrain,\n      syncOption = config.sync,\n      offsets = config.offset || [],\n      syncWidth = false,\n      syncHeight = false,\n      sourceClone = sourceRegion.clone();\n  /*\n   * Prepare the method arguments: positions, offsets, constrain and sync options\n   */\n\n  if (!Array.isArray(positions)) {\n    positions = positions ? [positions] : [];\n  }\n\n  if (!Array.isArray(offsets)) {\n    offsets = offsets ? [offsets] : [];\n  }\n\n  if (constrainTo) {\n    constrainTo = constrainTo === true ? Region.getDocRegion() : constrainTo.getRegion();\n  }\n\n  if (syncOption) {\n    if (syncOption.size) {\n      syncWidth = true;\n      syncHeight = true;\n    } else {\n      syncWidth = syncOption === true ? true : syncOption.width || false;\n      syncHeight = syncOption === true ? true : syncOption.height || false;\n    }\n  }\n\n  if (syncWidth) {\n    sourceClone.setWidth(targetRegion.getWidth());\n  }\n\n  if (syncHeight) {\n    sourceClone.setHeight(targetRegion.getHeight());\n  }\n\n  var offset,\n      i = 0,\n      len = positions.length,\n      pos,\n      intersection,\n      itArea,\n      maxArea = -1,\n      maxAreaIndex = -1;\n\n  for (; i < len; i++) {\n    pos = positions[i];\n    offset = offsets[i];\n    sourceClone.alignToRegion(targetRegion, pos);\n\n    if (offset) {\n      if (!Array.isArray(offset)) {\n        offset = offsets[i] = [offset.x || offset.left, offset.y || offset.top];\n      }\n\n      sourceClone.shift({\n        left: offset[0],\n        top: offset[1]\n      });\n    } //the source region is already aligned in the correct position\n\n\n    if (constrainTo) {\n      //if we have a constrain region, test for the constrain\n      intersection = sourceClone.getIntersection(constrainTo);\n\n      if (intersection && intersection.equals(sourceClone)) {\n        //constrain respected, so return (the aligned position)\n        sourceRegion.set(sourceClone);\n        return pos;\n      } else {\n        //the constrain was not respected, so continue trying\n        if (intersection && (itArea = intersection.getArea()) > maxArea) {\n          maxArea = itArea;\n          maxAreaIndex = i;\n        }\n      }\n    } else {\n      sourceRegion.set(sourceClone);\n      return pos;\n    }\n  } //no alignment respected the constraints\n\n\n  if (~maxAreaIndex) {\n    pos = positions[maxAreaIndex];\n    offset = offsets[maxAreaIndex];\n    sourceClone.alignToRegion(targetRegion, pos);\n\n    if (offset) {\n      sourceClone.shift({\n        left: offset[0],\n        top: offset[1]\n      });\n    } //we are sure an intersection exists, because of the way the maxAreaIndex was computed\n\n\n    intersection = sourceClone.getIntersection(constrainTo);\n    sourceClone.setRegion(intersection);\n    sourceClone.alignToRegion(targetRegion, pos);\n\n    if (offset) {\n      sourceClone.shift({\n        left: offset[0],\n        top: offset[1]\n      });\n    }\n\n    sourceRegion.set(sourceClone);\n    return pos;\n  }\n}\n\nmodule.exports = ALIGN_TO_NORMALIZED;","map":null,"metadata":{},"sourceType":"script"}