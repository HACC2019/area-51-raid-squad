{"ast":null,"code":"'use strict';\n\nvar hasOwn = require('hasown');\n\nvar newify = require('newify');\n\nvar assign = require('object-assign');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar inherits = require('./inherits');\n\nvar VALIDATE = require('./validate');\n\nvar objectToString = Object.prototype.toString;\n\nvar isObject = function isObject(value) {\n  return objectToString.apply(value) === '[object Object]';\n};\n\nfunction copyList(source, target, list) {\n  if (source) {\n    list.forEach(function (key) {\n      if (hasOwn(source, key)) {\n        target[key] = source[key];\n      }\n    });\n  }\n\n  return target;\n}\n/**\n * @class Region\n *\n * The Region is an abstraction that allows the developer to refer to rectangles on the screen,\n * and move them around, make diffs and unions, detect intersections, compute areas, etc.\n *\n * ## Creating a region\n *      var region = require('region')({\n *          top  : 10,\n *          left : 10,\n *          bottom: 100,\n *          right : 100\n *      })\n *      //this region is a square, 90x90, starting from (10,10) to (100,100)\n *\n *      var second = require('region')({ top: 10, left: 100, right: 200, bottom: 60})\n *      var union  = region.getUnion(second)\n *\n *      //the \"union\" region is a union between \"region\" and \"second\"\n */\n\n\nvar POINT_POSITIONS = {\n  cy: 'YCenter',\n  cx: 'XCenter',\n  t: 'Top',\n  tc: 'TopCenter',\n  tl: 'TopLeft',\n  tr: 'TopRight',\n  b: 'Bottom',\n  bc: 'BottomCenter',\n  bl: 'BottomLeft',\n  br: 'BottomRight',\n  l: 'Left',\n  lc: 'LeftCenter',\n  r: 'Right',\n  rc: 'RightCenter',\n  c: 'Center'\n};\n/**\n * @constructor\n *\n * Construct a new Region.\n *\n * Example:\n *\n *      var r = new Region({ top: 10, left: 20, bottom: 100, right: 200 })\n *\n *      //or, the same, but with numbers (can be used with new or without)\n *\n *      r = Region(10, 200, 100, 20)\n *\n *      //or, with width and height\n *\n *      r = Region({ top: 10, left: 20, width: 180, height: 90})\n *\n * @param {Number|Object} top The top pixel position, or an object with top, left, bottom, right properties. If an object is passed,\n * instead of having bottom and right, it can have width and height.\n *\n * @param {Number} right The right pixel position\n * @param {Number} bottom The bottom pixel position\n * @param {Number} left The left pixel position\n *\n * @return {Region} this\n */\n\nvar REGION = function REGION(top, right, bottom, left) {\n  if (!(this instanceof REGION)) {\n    return newify(REGION, arguments);\n  }\n\n  EventEmitter.call(this);\n\n  if (isObject(top)) {\n    copyList(top, this, ['top', 'right', 'bottom', 'left']);\n\n    if (top.bottom == null && top.height != null) {\n      this.bottom = this.top + top.height;\n    }\n\n    if (top.right == null && top.width != null) {\n      this.right = this.left + top.width;\n    }\n\n    if (top.emitChangeEvents) {\n      this.emitChangeEvents = top.emitChangeEvents;\n    }\n  } else {\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n\n  this[0] = this.left;\n  this[1] = this.top;\n  VALIDATE(this);\n};\n\ninherits(REGION, EventEmitter);\nassign(REGION.prototype, {\n  /**\n   * @cfg {Boolean} emitChangeEvents If this is set to true, the region\n   * will emit 'changesize' and 'changeposition' whenever the size or the position changs\n   */\n  emitChangeEvents: false,\n\n  /**\n   * Returns this region, or a clone of this region\n   * @param  {Boolean} [clone] If true, this method will return a clone of this region\n   * @return {Region}       This region, or a clone of this\n   */\n  getRegion: function getRegion(clone) {\n    return clone ? this.clone() : this;\n  },\n\n  /**\n   * Sets the properties of this region to those of the given region\n   * @param {Region/Object} reg The region or object to use for setting properties of this region\n   * @return {Region} this\n   */\n  setRegion: function setRegion(reg) {\n    if (reg instanceof REGION) {\n      this.set(reg.get());\n    } else {\n      this.set(reg);\n    }\n\n    return this;\n  },\n\n  /**\n   * Returns true if this region is valid, false otherwise\n   *\n   * @param  {Region} region The region to check\n   * @return {Boolean}        True, if the region is valid, false otherwise.\n   * A region is valid if\n   *  * left <= right  &&\n   *  * top  <= bottom\n   */\n  validate: function validate() {\n    return REGION.validate(this);\n  },\n  _before: function _before() {\n    if (this.emitChangeEvents) {\n      return copyList(this, {}, ['left', 'top', 'bottom', 'right']);\n    }\n  },\n  _after: function _after(before) {\n    if (this.emitChangeEvents) {\n      if (this.top != before.top || this.left != before.left) {\n        this.emitPositionChange();\n      }\n\n      if (this.right != before.right || this.bottom != before.bottom) {\n        this.emitSizeChange();\n      }\n    }\n  },\n  notifyPositionChange: function notifyPositionChange() {\n    this.emit('changeposition', this);\n  },\n  emitPositionChange: function emitPositionChange() {\n    this.notifyPositionChange();\n  },\n  notifySizeChange: function notifySizeChange() {\n    this.emit('changesize', this);\n  },\n  emitSizeChange: function emitSizeChange() {\n    this.notifySizeChange();\n  },\n\n  /**\n   * Add the given amounts to each specified side. Example\n   *\n   *      region.add({\n   *          top: 50,    //add 50 px to the top side\n   *          bottom: -100    //substract 100 px from the bottom side\n   *      })\n   *\n   * @param {Object} directions\n   * @param {Number} [directions.top]\n   * @param {Number} [directions.left]\n   * @param {Number} [directions.bottom]\n   * @param {Number} [directions.right]\n   *\n   * @return {Region} this\n   */\n  add: function add(directions) {\n    var before = this._before();\n\n    var direction;\n\n    for (direction in directions) {\n      if (hasOwn(directions, direction)) {\n        this[direction] += directions[direction];\n      }\n    }\n\n    this[0] = this.left;\n    this[1] = this.top;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * The same as {@link #add}, but substracts the given values\n   * @param {Object} directions\n   * @param {Number} [directions.top]\n   * @param {Number} [directions.left]\n   * @param {Number} [directions.bottom]\n   * @param {Number} [directions.right]\n   *\n   * @return {Region} this\n   */\n  substract: function substract(directions) {\n    var before = this._before();\n\n    var direction;\n\n    for (direction in directions) {\n      if (hasOwn(directions, direction)) {\n        this[direction] -= directions[direction];\n      }\n    }\n\n    this[0] = this.left;\n    this[1] = this.top;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Retrieves the size of the region.\n   * @return {Object} An object with {width, height}, corresponding to the width and height of the region\n   */\n  getSize: function getSize() {\n    return {\n      width: this.width,\n      height: this.height\n    };\n  },\n\n  /**\n   * Move the region to the given position and keeps the region width and height.\n   *\n   * @param {Object} position An object with {top, left} properties. The values in {top,left} are used to move the region by the given amounts.\n   * @param {Number} [position.left]\n   * @param {Number} [position.top]\n   *\n   * @return {Region} this\n   */\n  setPosition: function setPosition(position) {\n    var width = this.width;\n    var height = this.height;\n\n    if (position.left != undefined) {\n      position.right = position.left + width;\n    }\n\n    if (position.top != undefined) {\n      position.bottom = position.top + height;\n    }\n\n    return this.set(position);\n  },\n\n  /**\n   * Sets both the height and the width of this region to the given size.\n   *\n   * @param {Number} size The new size for the region\n   * @return {Region} this\n   */\n  setSize: function setSize(size) {\n    if (size.height != undefined && size.width != undefined) {\n      return this.set({\n        right: this.left + size.width,\n        bottom: this.top + size.height\n      });\n    }\n\n    if (size.width != undefined) {\n      this.setWidth(size.width);\n    }\n\n    if (size.height != undefined) {\n      this.setHeight(size.height);\n    }\n\n    return this;\n  },\n\n  /**\n   * @chainable\n   *\n   * Sets the width of this region\n   * @param {Number} width The new width for this region\n   * @return {Region} this\n   */\n  setWidth: function setWidth(width) {\n    return this.set({\n      right: this.left + width\n    });\n  },\n\n  /**\n   * @chainable\n   *\n   * Sets the height of this region\n   * @param {Number} height The new height for this region\n   * @return {Region} this\n   */\n  setHeight: function setHeight(height) {\n    return this.set({\n      bottom: this.top + height\n    });\n  },\n\n  /**\n   * Sets the given properties on this region\n   *\n   * @param {Object} directions an object containing top, left, and EITHER bottom, right OR width, height\n   * @param {Number} [directions.top]\n   * @param {Number} [directions.left]\n   *\n   * @param {Number} [directions.bottom]\n   * @param {Number} [directions.right]\n   *\n   * @param {Number} [directions.width]\n   * @param {Number} [directions.height]\n   *\n   *\n   * @return {Region} this\n   */\n  set: function set(directions) {\n    var before = this._before();\n\n    copyList(directions, this, ['left', 'top', 'bottom', 'right']);\n\n    if (directions.bottom == null && directions.height != null) {\n      this.bottom = this.top + directions.height;\n    }\n\n    if (directions.right == null && directions.width != null) {\n      this.right = this.left + directions.width;\n    }\n\n    this[0] = this.left;\n    this[1] = this.top;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Retrieves the given property from this region. If no property is given, return an object\n   * with {left, top, right, bottom}\n   *\n   * @param {String} [dir] the property to retrieve from this region\n   * @return {Number/Object}\n   */\n  get: function get(dir) {\n    return dir ? this[dir] : copyList(this, {}, ['left', 'right', 'top', 'bottom']);\n  },\n\n  /**\n   * Shifts this region to either top, or left or both.\n   * Shift is similar to {@link #add} by the fact that it adds the given dimensions to top/left sides, but also adds the given dimensions\n   * to bottom and right\n   *\n   * @param {Object} directions\n   * @param {Number} [directions.top]\n   * @param {Number} [directions.left]\n   *\n   * @return {Region} this\n   */\n  shift: function shift(directions) {\n    var before = this._before();\n\n    if (directions.top) {\n      this.top += directions.top;\n      this.bottom += directions.top;\n    }\n\n    if (directions.left) {\n      this.left += directions.left;\n      this.right += directions.left;\n    }\n\n    this[0] = this.left;\n    this[1] = this.top;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Same as {@link #shift}, but substracts the given values\n   * @chainable\n   *\n   * @param {Object} directions\n   * @param {Number} [directions.top]\n   * @param {Number} [directions.left]\n   *\n   * @return {Region} this\n   */\n  unshift: function unshift(directions) {\n    if (directions.top) {\n      directions.top *= -1;\n    }\n\n    if (directions.left) {\n      directions.left *= -1;\n    }\n\n    return this.shift(directions);\n  },\n\n  /**\n   * Compare this region and the given region. Return true if they have all the same size and position\n   * @param  {Region} region The region to compare with\n   * @return {Boolean}       True if this and region have same size and position\n   */\n  equals: function equals(region) {\n    return this.equalsPosition(region) && this.equalsSize(region);\n  },\n\n  /**\n   * Returns true if this region has the same bottom,right properties as the given region\n   * @param  {Region/Object} size The region to compare against\n   * @return {Boolean}       true if this region is the same size as the given size\n   */\n  equalsSize: function equalsSize(size) {\n    var isInstance = size instanceof REGION;\n    var s = {\n      width: size.width == null && isInstance ? size.getWidth() : size.width,\n      height: size.height == null && isInstance ? size.getHeight() : size.height\n    };\n    return this.getWidth() == s.width && this.getHeight() == s.height;\n  },\n\n  /**\n   * Returns true if this region has the same top,left properties as the given region\n   * @param  {Region} region The region to compare against\n   * @return {Boolean}       true if this.top == region.top and this.left == region.left\n   */\n  equalsPosition: function equalsPosition(region) {\n    return this.top == region.top && this.left == region.left;\n  },\n\n  /**\n   * Adds the given ammount to the left side of this region\n   * @param {Number} left The ammount to add\n   * @return {Region} this\n   */\n  addLeft: function addLeft(left) {\n    var before = this._before();\n\n    this.left = this[0] = this.left + left;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Adds the given ammount to the top side of this region\n   * @param {Number} top The ammount to add\n   * @return {Region} this\n   */\n  addTop: function addTop(top) {\n    var before = this._before();\n\n    this.top = this[1] = this.top + top;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Adds the given ammount to the bottom side of this region\n   * @param {Number} bottom The ammount to add\n   * @return {Region} this\n   */\n  addBottom: function addBottom(bottom) {\n    var before = this._before();\n\n    this.bottom += bottom;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Adds the given ammount to the right side of this region\n   * @param {Number} right The ammount to add\n   * @return {Region} this\n   */\n  addRight: function addRight(right) {\n    var before = this._before();\n\n    this.right += right;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Minimize the top side.\n   * @return {Region} this\n   */\n  minTop: function minTop() {\n    return this.expand({\n      top: 1\n    });\n  },\n\n  /**\n   * Minimize the bottom side.\n   * @return {Region} this\n   */\n  maxBottom: function maxBottom() {\n    return this.expand({\n      bottom: 1\n    });\n  },\n\n  /**\n   * Minimize the left side.\n   * @return {Region} this\n   */\n  minLeft: function minLeft() {\n    return this.expand({\n      left: 1\n    });\n  },\n\n  /**\n   * Maximize the right side.\n   * @return {Region} this\n   */\n  maxRight: function maxRight() {\n    return this.expand({\n      right: 1\n    });\n  },\n\n  /**\n   * Expands this region to the dimensions of the given region, or the document region, if no region is expanded.\n   * But only expand the given sides (any of the four can be expanded).\n   *\n   * @param {Object} directions\n   * @param {Boolean} [directions.top]\n   * @param {Boolean} [directions.bottom]\n   * @param {Boolean} [directions.left]\n   * @param {Boolean} [directions.right]\n   *\n   * @param {Region} [region] the region to expand to, defaults to the document region\n   * @return {Region} this region\n   */\n  expand: function expand(directions, region) {\n    var docRegion = region || REGION.getDocRegion();\n    var list = [];\n    var direction;\n\n    var before = this._before();\n\n    for (direction in directions) {\n      if (hasOwn(directions, direction)) {\n        list.push(direction);\n      }\n    }\n\n    copyList(docRegion, this, list);\n    this[0] = this.left;\n    this[1] = this.top;\n\n    this._after(before);\n\n    return this;\n  },\n\n  /**\n   * Returns a clone of this region\n   * @return {Region} A new region, with the same position and dimension as this region\n   */\n  clone: function clone() {\n    return new REGION({\n      top: this.top,\n      left: this.left,\n      right: this.right,\n      bottom: this.bottom\n    });\n  },\n\n  /**\n   * Returns true if this region contains the given point\n   * @param {Number/Object} x the x coordinate of the point\n   * @param {Number} [y] the y coordinate of the point\n   *\n   * @return {Boolean} true if this region constains the given point, false otherwise\n   */\n  containsPoint: function containsPoint(x, y) {\n    if (arguments.length == 1) {\n      y = x.y;\n      x = x.x;\n    }\n\n    return this.left <= x && x <= this.right && this.top <= y && y <= this.bottom;\n  },\n\n  /**\n   *\n   * @param region\n   *\n   * @return {Boolean} true if this region contains the given region, false otherwise\n   */\n  containsRegion: function containsRegion(region) {\n    return this.containsPoint(region.left, region.top) && this.containsPoint(region.right, region.bottom);\n  },\n\n  /**\n   * Returns an object with the difference for {top, bottom} positions betwen this and the given region,\n   *\n   * See {@link #diff}\n   * @param  {Region} region The region to use for diff\n   * @return {Object}        {top,bottom}\n   */\n  diffHeight: function diffHeight(region) {\n    return this.diff(region, {\n      top: true,\n      bottom: true\n    });\n  },\n\n  /**\n   * Returns an object with the difference for {left, right} positions betwen this and the given region,\n   *\n   * See {@link #diff}\n   * @param  {Region} region The region to use for diff\n   * @return {Object}        {left,right}\n   */\n  diffWidth: function diffWidth(region) {\n    return this.diff(region, {\n      left: true,\n      right: true\n    });\n  },\n\n  /**\n   * Returns an object with the difference in sizes for the given directions, between this and region\n   *\n   * @param  {Region} region     The region to use for diff\n   * @param  {Object} directions An object with the directions to diff. Can have any of the following keys:\n   *  * left\n   *  * right\n   *  * top\n   *  * bottom\n   *\n   * @return {Object} and object with the same keys as the directions object, but the values being the\n   * differences between this region and the given region\n   */\n  diff: function diff(region, directions) {\n    var result = {};\n    var dirName;\n\n    for (dirName in directions) {\n      if (hasOwn(directions, dirName)) {\n        result[dirName] = this[dirName] - region[dirName];\n      }\n    }\n\n    return result;\n  },\n\n  /**\n   * Returns the position, in {left,top} properties, of this region\n   *\n   * @return {Object} {left,top}\n   */\n  getPosition: function getPosition() {\n    return {\n      left: this.left,\n      top: this.top\n    };\n  },\n\n  /**\n   * Returns the point at the given position from this region.\n   *\n   * @param {String} position Any of:\n   *\n   *  * 'cx' - See {@link #getPointXCenter}\n   *  * 'cy' - See {@link #getPointYCenter}\n   *  * 'b'  - See {@link #getPointBottom}\n   *  * 'bc' - See {@link #getPointBottomCenter}\n   *  * 'l'  - See {@link #getPointLeft}F\n   *  * 'lc' - See {@link #getPointLeftCenter}\n   *  * 't'  - See {@link #getPointTop}\n   *  * 'tc' - See {@link #getPointTopCenter}\n   *  * 'r'  - See {@link #getPointRight}\n   *  * 'rc' - See {@link #getPointRightCenter}\n   *  * 'c'  - See {@link #getPointCenter}\n   *  * 'tl' - See {@link #getPointTopLeft}\n   *  * 'bl' - See {@link #getPointBottomLeft}\n   *  * 'br' - See {@link #getPointBottomRight}\n   *  * 'tr' - See {@link #getPointTopRight}\n   *\n   * @param {Boolean} asLeftTop\n   *\n   * @return {Object} either an object with {x,y} or {left,top} if asLeftTop is true\n   */\n  getPoint: function getPoint(position, asLeftTop) {\n    //<debug>\n    if (!POINT_POSITIONS[position]) {\n      console.warn('The position ', position, ' could not be found! Available options are tl, bl, tr, br, l, r, t, b.');\n    } //</debug>\n\n\n    var method = 'getPoint' + POINT_POSITIONS[position],\n        result = this[method]();\n\n    if (asLeftTop) {\n      return {\n        left: result.x,\n        top: result.y\n      };\n    }\n\n    return result;\n  },\n\n  /**\n   * Returns a point with x = null and y being the middle of the left region segment\n   * @return {Object} {x,y}\n   */\n  getPointYCenter: function getPointYCenter() {\n    return {\n      x: null,\n      y: this.top + this.getHeight() / 2\n    };\n  },\n\n  /**\n   * Returns a point with y = null and x being the middle of the top region segment\n   * @return {Object} {x,y}\n   */\n  getPointXCenter: function getPointXCenter() {\n    return {\n      x: this.left + this.getWidth() / 2,\n      y: null\n    };\n  },\n\n  /**\n   * Returns a point with x = null and y the region top position on the y axis\n   * @return {Object} {x,y}\n   */\n  getPointTop: function getPointTop() {\n    return {\n      x: null,\n      y: this.top\n    };\n  },\n\n  /**\n   * Returns a point that is the middle point of the region top segment\n   * @return {Object} {x,y}\n   */\n  getPointTopCenter: function getPointTopCenter() {\n    return {\n      x: this.left + this.getWidth() / 2,\n      y: this.top\n    };\n  },\n\n  /**\n   * Returns a point that is the top-left point of the region\n   * @return {Object} {x,y}\n   */\n  getPointTopLeft: function getPointTopLeft() {\n    return {\n      x: this.left,\n      y: this.top\n    };\n  },\n\n  /**\n   * Returns a point that is the top-right point of the region\n   * @return {Object} {x,y}\n   */\n  getPointTopRight: function getPointTopRight() {\n    return {\n      x: this.right,\n      y: this.top\n    };\n  },\n\n  /**\n   * Returns a point with x = null and y the region bottom position on the y axis\n   * @return {Object} {x,y}\n   */\n  getPointBottom: function getPointBottom() {\n    return {\n      x: null,\n      y: this.bottom\n    };\n  },\n\n  /**\n   * Returns a point that is the middle point of the region bottom segment\n   * @return {Object} {x,y}\n   */\n  getPointBottomCenter: function getPointBottomCenter() {\n    return {\n      x: this.left + this.getWidth() / 2,\n      y: this.bottom\n    };\n  },\n\n  /**\n   * Returns a point that is the bottom-left point of the region\n   * @return {Object} {x,y}\n   */\n  getPointBottomLeft: function getPointBottomLeft() {\n    return {\n      x: this.left,\n      y: this.bottom\n    };\n  },\n\n  /**\n   * Returns a point that is the bottom-right point of the region\n   * @return {Object} {x,y}\n   */\n  getPointBottomRight: function getPointBottomRight() {\n    return {\n      x: this.right,\n      y: this.bottom\n    };\n  },\n\n  /**\n   * Returns a point with y = null and x the region left position on the x axis\n   * @return {Object} {x,y}\n   */\n  getPointLeft: function getPointLeft() {\n    return {\n      x: this.left,\n      y: null\n    };\n  },\n\n  /**\n   * Returns a point that is the middle point of the region left segment\n   * @return {Object} {x,y}\n   */\n  getPointLeftCenter: function getPointLeftCenter() {\n    return {\n      x: this.left,\n      y: this.top + this.getHeight() / 2\n    };\n  },\n\n  /**\n   * Returns a point with y = null and x the region right position on the x axis\n   * @return {Object} {x,y}\n   */\n  getPointRight: function getPointRight() {\n    return {\n      x: this.right,\n      y: null\n    };\n  },\n\n  /**\n   * Returns a point that is the middle point of the region right segment\n   * @return {Object} {x,y}\n   */\n  getPointRightCenter: function getPointRightCenter() {\n    return {\n      x: this.right,\n      y: this.top + this.getHeight() / 2\n    };\n  },\n\n  /**\n   * Returns a point that is the center of the region\n   * @return {Object} {x,y}\n   */\n  getPointCenter: function getPointCenter() {\n    return {\n      x: this.left + this.getWidth() / 2,\n      y: this.top + this.getHeight() / 2\n    };\n  },\n\n  /**\n   * @return {Number} returns the height of the region\n   */\n  getHeight: function getHeight() {\n    return this.bottom - this.top;\n  },\n\n  /**\n   * @return {Number} returns the width of the region\n   */\n  getWidth: function getWidth() {\n    return this.right - this.left;\n  },\n\n  /**\n   * @return {Number} returns the top property of the region\n   */\n  getTop: function getTop() {\n    return this.top;\n  },\n\n  /**\n   * @return {Number} returns the left property of the region\n   */\n  getLeft: function getLeft() {\n    return this.left;\n  },\n\n  /**\n   * @return {Number} returns the bottom property of the region\n   */\n  getBottom: function getBottom() {\n    return this.bottom;\n  },\n\n  /**\n   * @return {Number} returns the right property of the region\n   */\n  getRight: function getRight() {\n    return this.right;\n  },\n\n  /**\n   * Returns the area of the region\n   * @return {Number} the computed area\n   */\n  getArea: function getArea() {\n    return this.getWidth() * this.getHeight();\n  },\n  constrainTo: function constrainTo(contrain) {\n    var intersect = this.getIntersection(contrain);\n    var shift;\n\n    if (!intersect || !intersect.equals(this)) {\n      var contrainWidth = contrain.getWidth(),\n          contrainHeight = contrain.getHeight();\n\n      if (this.getWidth() > contrainWidth) {\n        this.left = contrain.left;\n        this.setWidth(contrainWidth);\n      }\n\n      if (this.getHeight() > contrainHeight) {\n        this.top = contrain.top;\n        this.setHeight(contrainHeight);\n      }\n\n      shift = {};\n\n      if (this.right > contrain.right) {\n        shift.left = contrain.right - this.right;\n      }\n\n      if (this.bottom > contrain.bottom) {\n        shift.top = contrain.bottom - this.bottom;\n      }\n\n      if (this.left < contrain.left) {\n        shift.left = contrain.left - this.left;\n      }\n\n      if (this.top < contrain.top) {\n        shift.top = contrain.top - this.top;\n      }\n\n      this.shift(shift);\n      return true;\n    }\n\n    return false;\n  },\n  __IS_REGION: true\n  /**\n   * @property {Number} top\n   */\n\n  /**\n   * @property {Number} right\n   */\n\n  /**\n   * @property {Number} bottom\n   */\n\n  /**\n   * @property {Number} left\n   */\n\n  /**\n   * @property {Number} [0] the top property\n   */\n\n  /**\n   * @property {Number} [1] the left property\n   */\n\n  /**\n   * @method getIntersection\n   * Returns a region that is the intersection of this region and the given region\n   * @param  {Region} region The region to intersect with\n   * @return {Region}        The intersection region\n   */\n\n  /**\n   * @method getUnion\n   * Returns a region that is the union of this region with the given region\n   * @param  {Region} region  The region to make union with\n   * @return {Region}        The union region. The smallest region that contains both this and the given region.\n   */\n\n});\nObject.defineProperties(REGION.prototype, {\n  width: {\n    get: function get() {\n      return this.getWidth();\n    },\n    set: function set(width) {\n      return this.setWidth(width);\n    }\n  },\n  height: {\n    get: function get() {\n      return this.getHeight();\n    },\n    set: function set(height) {\n      return this.setHeight(height);\n    }\n  }\n});\n\nrequire('./statics')(REGION);\n\nmodule.exports = REGION;","map":null,"metadata":{},"sourceType":"script"}